---
title: CPU 성능 시간에 대한 이야기들
description: CPU 성능 시간의 정의와 Amdahl의 법칙
tag:
  - 컴퓨터 구조
postId: 626818
date: Sun Jun 09 2024
time: 1717918625927
---

# `CPU` 성능

## 컴퓨팅 성능 을 어떻게 판단할까 ?

빠른 컴퓨팅 속도를 나타내는 지표는 여러 가지가 존재하지만 대표적인 지표는 다음 두 가지이다.

- 하나의 태스크를 시작부터 종료까지 걸리는 시간을 의미하는 **지연 시간**
- 여러개의 테스크를 마치는데 까지 걸리는 시간을 의미하는 **처리량**

이 중 개인용 PC에 맞는 지표는 하나의 태스크를 마치는데 까지 필요한 지연 시간일 것이다.

지연 시간에 영향을 미치는 요소는 두 가지가 존재한다.

- 순수하게 `CPU` 가 해당 프로세스를 다루는데 걸리는 `CPU` 시간
- `I/O` 처리로 인해 프로세스가 `CPU` 에 할당되지 않고 `blocking` 되어 있는 시간

지연 시간이란 다음과 같은 지표로 표현 할 수 있다.

**지연시간 = CPU 시간 + blocking 시간**

사용자 경험이 좋기 위해선 최대한 지연 시간이 짧아야 한다. 지연 시간이 짧다는 것은 더욱 빠르게 하나의 태스크를 처리했다는 것이기 떄문이다.

## `CPU` 시간에 집중해보자

컴퓨터의 성능을 평가하는 지표에서 지연 시간은 개인용 PC 에서 사용자 경험에 영향을 미치는 가장 큰 요소일 것이다.

다만 `blocking` 시간은 프로세스의 특징에 따라 다르기 때문에 고정적인 지표로 보기 힘들다.

하지만 `CPU` 시간은 프로세스의 특징과 상관 없이 순수하게 하드웨어인 `CPU` 의 성능을 평가 할 수 있는 지표가 되기 때문에 이번 `docs` 에선 `CPU` 시간에 대해서 공부해보자

### `CPU` 는 어떻게 프로세스를 처리할까 ?

---

컴퓨터가 프로세스를 실행한다는 것은 결국 프로세스에 적힌 명령어들을 `CPU` 에서 처리하여 실행하는 것을 의미한다.

프로세스들의 명령어는 메모리에 저장되는데 , `CPU` 는 일정한 주기로 메모리에 있는 명령어들을 가져와 `CPU` 에서 실행 시킨다.

이 때 일중헌 주기로 프로세스들을 처리하기 위하 `클럭` 이라는 스케줄링 기법을 사용한다.

클럭 기법은 일정한 주기에 맞춰, 마치 원형 시계가 돌아가듯 모든 프로세스들을 공평하게 실행 시키는 기법을 의미한다.

그렇다면 `A` 라는 프로세스가 `CPU` 에서 처리되는 시간은 다음과 같이 표현 할 수 있다.

> A 의 CPU 시간 = A 를 실행하기 위해 돌아가야 하는 클럭의 사이클 수 \* 클럭이 1회 도는데 걸리는 시간

이걸 좀 더 전문 용어로 표현하면 다음과 같이 표현 할 수 있다.

> A의 CPU 성능 시간 = 클럭 사이클 수 \* 클럭 주기

클럭 사이클은 일정한 주기를 갖고 반복되기 때문에 시간에 따른 진동 횟수를 의미하는 `Hz` 로 표현 되기도 하고 , 1초당 횟수로 표현하는 `/s` 로 표현되기도 한다.

이 때 `1Hz` 는 초당 클럭 회전 횟수로 10 \*\* 9 번을 의미한다고 한다.

> 어마무시하게 빠르다.

그렇다면 `A` 프로세스를 끝마치기 위해 필요한 클럭 사이클 수는 어떻게 계산할까 ?

> `A` 프로세스를 끝마치기 위해 필요한 클럭 사이클 수 = `A` 의 명령어 수 \* 명령어 별 처리 시간

다음과 같이 계산 할 수 있다.

이 때 명령어 별 처리 시간을 명령어 별로 모두 구하기 보다 평균적인 명령어 처리 시간인 `CPI (Clock cycles per instruction)` 로 정의해서 사용한다.

> `CPI` = 클럭 사이클 수 / 명령어 수

결국 어떤 프로세스의 `CPU` 성능이란 다음과 같이 표기 할 수 있다.

> `A` 의 `CPU` 성능 시간 = 명령어 수 \* 명령어 별 평균 소요 시간 (클럭 사이클 수) \* 클럭 주기 (1회 클럭을 도는 시간)

이 때 클럭 주기는 1 틱의 클럭을 도는데 걸리는 시간인 클럭 속도의 역수로 표현 할 수 있다.

결국엔 다음과 같이 표현 가능하다.

> `A` 의 `CPU` 성능 시간 = 명령어 수 \* 명령어 별 평균 소요 시간 (클럭 사이클 수) \* 클럭 주기 (1회 클럭을 도는 시간)
>
> = `A` 의 `CPU` 성능 시간 = (명령어 수 \* 명령어 별 평균 소요 시간 [클럭 사이클 수]) / 클럭 속도

`CPU` 성능 시간이 빠르려면 결국 명령어 별 평균 소요 시간이 작거나 , 클럭이 속도가 빠를 경우 성능 시간이 짧아 빠른 `CPU` 라고 볼 수 있다.

### 🤔 스스로 점검하기

> ### `Q`. `Java` 로 작성된 어떤 프로그램을 실행하는데 까지 걸리는 시간은 15초였다. 이 떄 새로운 컴파일러를 사용하여 명령어 개수의 비율을 0.6 으로 줄였으나 `CPI` 는 1.1 배 늘어났다. 새로운 컴파일러를 사용해 해당 프로그램을 실행하는데 얼만큼의 시간이 걸리겠는가 ?

이전 명령어 개수의 비율을 `I` , `CPI` 를 `C` 라고 두면 다음과 같이 생각 할 수 있다.

- 15초 / 사이클 주기 = `I` \* `C`

이 때 동일한 하드웨어를 이용하였다고 가정하여 사이클 주기를 1초로 잡고 생각해본다면 다음과 같은 값이 나온다.

`I` \* `C` = 15

이후 새로운 컴파일러를 이용한 성능 시간은 다음과 같이 구할 수 있다.

`0.6 & I` _ `1.1 _ C` = 새로운 컴파일러를 이용한 성능 시간

이 때 `I * C = 15` 였으니 결국 새로운 성능 시간은 `0.6 * 1.1 * 15` 로 `9.9` 초가 정답이다.

# 성능 개선의 오류와 함정

`CPU` 성능을 개선하기 위한 여러 접근 방법들엔 항상 위험한 오류와 함정들이 도사리고 있다.

이번 챕터에선 `CPU` 성능을 높히기 전 생각해봐야 하는 여러 오류와 함정들을 다룬다.

## `Amdahl` 의 법칙

`Amdhal` 의 법칙은 다음과 같다.

> 개선 후 실행 시간 = 개선에 의해 영향을 받는 실행 시간 / 개선의 크기 + 영향을 받지 않는 실행 시간

즉 , 예를 들어 현재 프로세스가 100초의 시간이 걸리고 , A 작업은 80초 B 작업은 20초가 걸린다고 해보자

이 때 `A` 작업을 몇 배 빠르게 개선해야 실행 시간을 50초까지 줄일 수 있을까 ?

> 50초 = 80초 / 개선의 크기 + 20초
>
> 30초 = 80초 / 개선의 크기
>
> 개선의 크기 = 8/3 , 약 2.66.. 배

개선 후 실행 시간을 절반으로 줄이기 위해선 `A` 작업을 2.66배 빠르게 해야 한다는 공식이 나온다.

그렇다면 어떤 작업을 무한하게 빠르게 한다면 개선 시간을 우리가 원하는 만큼 줄일 수 있을까 ?

그렇지 않다.

> 개선 후 실행 시간 = 개선에 의해 영향을 받는 실행 시간 / 개선의 크기 + 영향을 받지 않는 실행 시간

해당 공식을 개선의 크기를 좌변에 두고 전개해본다면 다음과 같다.

> 개선의 크기 = 개선에 의해 영향을 받는 실행 시간 / (개선 후 실행 시간 - 영향을 받지 않는 실행 시간)

개선의 크기의 상한 선은 개선 후 실행 시간이 영향을 받지 않는 실행 실행시간 보다 클 때 까지만 정의된다.

즉 ,위 예시에서 100초의 전체 작업 시간을 줄일 수 있는 최대 상한선은 20.00001 초이다.

아무리 `A` 작업을 빠르게 줄인다고 하더라도 영향을 받지 않는 시간인 20초만큼은 소요되기 때문이다.

해당 법칙은 비단 컴퓨팅 뿐 아니라 우리 일상 속에서도 적용 가능하다.
